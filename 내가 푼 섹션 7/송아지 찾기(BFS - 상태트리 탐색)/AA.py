import sys
# 큐를 쓰려면 콜렉션에서 디큐를 임포트 해야한다.
from collections import deque
sys.stdin = open("input.txt", "rt")


# BFS(넓이 우선 탐색)
# -> 큐를 이용하는 탐색

# BFS은 레벨 우선 탐색을 한다.
#
#             0
#           /  \
#          1    2
#         / \  / \
#        3  4 5  6
#
# 위의 이진 트리에서 BFS는 0 -> 1 -> 2 -> 3 -> 4 -> 5 -> 6
# 위와 같이 같은 레벨에 있는 노드를 우선 탐색한다.

# BFS는 큐를 이용한다. 선입선출, 큐에 0번을 넣고 pop()을 해서 연결된 1과 2를 넣는다.
# 그 다음에 1을 pop()하고 1과 연결된 3과 4를 넣는다.
# 그 다음 2를 pop()하고 2와 연결된 5와 6을 넣는다.

# 이 문제에서 상태 트리는 1. 앞으로 1, 2. 앞으로 2, 3. 앞으로 5다.
# 위와 같이 상태 트리의 노드는 3개가 된다.
# 값이 주어지면 그 값에 상태 변화를 가한 3 노드를 상태트리로 지정해야한다.

# 이 문제에서는 dis라는 움직힌 횟수를 표현한 리스트가 필요하다.
# 인덱스에 따라 지점을 방문하면 전 지점의 값에 1을 더한다.

# 방문 리스트도 필요하다. 방문하지 않은 지점에서 다시 방문한 지점으로 갈 이유가 없다.

MAX = 100000

# 0번부터 생기기 때문에 MAX+1
# 체크리스트
ch = [0] * (MAX + 1)
# 거리리스트
dis = [0] * (MAX + 1)

# n = 시작 노드, m = 도착 노드
n,m = map(int, input().split())

# 시작노드 방문
ch[n] = 1
# 현재 움직인 횟수는 0
dis[n] = 0

# 디큐 사용
dQ = deque()
dQ.append(n)

# BFS의 기본 정지 조건은 큐에 값이 남아있지 않을 떄다.
while dQ:
    # now는 지금 큐 맨 앞의 값
    now = dQ.popleft()
    # 문제에서 주어진 정지 조건, 목적지 도착
    if now == m:
        break
    # next는 now의 자식 노드들이다.
    # in(데이터,데이터,데이테...)의 표현식도 알아두자.
    # 이러면 in()안에 있는 갯수만큼 돈다.
    for next in(now-1,now+1,now+5):
        # 음수 좌표는 가면 안된다.
        if MAX>= next > 0:
            # 방문을 했던 곳은 가면 안된다.
            # 움직인 최소 값을 찾아야하기 때문에 다시 돌아가는 루트는 필요가 없는 것이다.
            if ch[next] == 0:
                dQ.append(next)
                # 방문 체크
                ch[next] = 1
                # 움직인 횟수 체크
                # 전 노드의 움직인 횟수 + 1
                dis[next] = dis[now] + 1 
print(dis[m])


