import sys
sys.stdin=open("input.txt","r")

# 냅색 알고리즘

# 다이나믹 프로그래밍은 메모이제이션에서 담는 값의 의미를 잘 아는 것이 중요하다.
# 현재 문제에서 메모이제이션은 현재 인덱스 j 가방에서 j 무게에 담는 보석의 최대 가치
# j무게가 한계치
# 거기에 담을 수 있는 보석의 최대 가치
# 냅색 알고리즘은 보통 무게가 한정되어 있을 때 담을 수 있는 최대 가치 이런 문제가 나온다.
# 메모 리스트의 인덱스 -> 무게

# 냅색 알고리즘 기본 체계

# 보석의 무게 -> w
# 보석의 가치 -> v
# memo[j] = memo[j-w] + v (최대 가치 수식)

# 하지만 이미 같은 인덱스에 적혀있는 최대 가치가 현재 보석의 상황에서의 최대 가치보다 크다면 그냥 납둔다.
# 반대로 현재 보석의 상황에서의 최대 가치가 더 크다면 바꿔준다.




if __name__ == "__main__":
    n,m = map(int,input().split())

    # 무게 기준이다, m이 무게이므로 무게의 제한을 두자
    memo = [0] * (m+1)
    
    # 보석의 객수 만큼 돌아야한다.
    for i in range(n):
        w, v = map(int,input().split())
        # 현재 보석의 무게부터 시작하자
        # 냅색 알고리즘 기본 체계
        for j in range(w,m+1):
            if memo[j-w] + v > memo[j]:
                memo[j] = memo[j-w] + v
    print(memo[m])
            