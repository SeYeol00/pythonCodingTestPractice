import sys
sys.stdin=open("input.txt","r")


# 메모 리스트의 인덱스 -> 시간
# 값은 최대 점수
# 여기서 함정은 한 유형당 한 개만 풀 수 있다라는 조건이다.
# 다른 문제는 무한정으로 주어졌지만 조건이 다르다.

# 갯수에 조건이 달려있으면 행렬을 통해서 풀어야한다.
# 문제가 한 개씩만 풀어야하기 때문에 행렬로 하는게 맞다

# 냅색은 보통 이차원으로 푼다.
# 하지만 코테에서는 행렬이 큰 메모리를 잡아먹기 때문에 행렬로 잘 안 쓴다.
# 시간 복잡도도 늘어나고 속도도 느려진다.

# 해결방법은 일차원 리스트를 뒤에서 부터 푸는 것이다. 
# 탑 다운 방식
# 이러면 절대 문제가 중복이 되지 않는다.
# 즉 for문을 뒤로 돌리는 것이다. for i in range(m, time, -1)
# 리스트의 앞에 있는 값을 참조하기 때문에 두 번 풀 일은 없다.


if __name__ == "__main__":
    n,m = map(int, input().split())
    
    memo = [0] * (m+1)

    for i in range(1,n):
        score,time = map(int, input().split())
        # 해결방법은 일차원 리스트를 뒤에서 부터 푸는 것이다. 
        # 이러면 절대 문제가 중복이 되지 않는다.
        for j in range(m, time-1, -1):
            # 문제에서 접근할 때 i-1을 행으로 인덱싱 해야한다.
            # 이를 통해 아직 i번을 풀지 않은 상태에서 score를 더해야한다.
            # 그래야 이번에 들어가는 값이 각 문제당 한 번만 들어가게 된다.
            # j - time인 이유는 이 문제를 푼다는 가정을 하기 때문이다.
            if memo[j] < memo[j-time] + score:
                memo[j] = memo[j-time] + score

    print(memo)